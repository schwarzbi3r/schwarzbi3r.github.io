<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SchwarzBier</title><link>https://SchwarzBi3r.github.io/</link><description>Recent content on SchwarzBier</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 09 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://SchwarzBi3r.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Benchmarking Solana programs compute units</title><link>https://SchwarzBi3r.github.io/posts/2022-03-09-solana-compute-units-benchmark/</link><pubDate>Wed, 09 Mar 2022 00:00:00 +0000</pubDate><guid>https://SchwarzBi3r.github.io/posts/2022-03-09-solana-compute-units-benchmark/</guid><description>Or, why you shouldn&amp;rsquo;t log a public key One of the limitations of smart contract development is that you typically have some steep constraints on the resources your contract can use during execution. One of those constraints in nearly every runtime is a limitation on the number of CPU cycles you can use. In the Solana world, these are represented as &amp;lsquo;compute units&amp;rsquo;.
Not only is there a hard limit (200k), but there&amp;rsquo;s also a cost associated with them, similar to how gas fees work in the Ethereum world.</description></item><item><title>Bump distribution of findProgramAddress</title><link>https://SchwarzBi3r.github.io/posts/2022-03-04-bump-distribution/</link><pubDate>Fri, 04 Mar 2022 00:00:00 +0000</pubDate><guid>https://SchwarzBi3r.github.io/posts/2022-03-04-bump-distribution/</guid><description>There&amp;rsquo;s some frequent misunderstanding when it comes to PDA&amp;rsquo;s on Solana, starting with the &amp;lsquo;bump&amp;rsquo; value.
First, let&amp;rsquo;s look at what makes up a PDA. A PDA, or Program Derived Address, is an address on Solana that satifies two requirements.
&amp;ldquo;Program address must not lie on the ed25519 curve to ensure there is no associated private key&amp;rdquo; - This means that there&amp;rsquo;s no corresponding private key for the public address; no one will ever be able to sign a transaction with this key.</description></item><item><title>Anchor/Solana safety check you get for free</title><link>https://SchwarzBi3r.github.io/posts/2022-02-22-solana-anchor-safety-checks/</link><pubDate>Mon, 21 Feb 2022 00:00:00 +0000</pubDate><guid>https://SchwarzBi3r.github.io/posts/2022-02-22-solana-anchor-safety-checks/</guid><description>When you&amp;rsquo;re writing any Solana contract, it&amp;rsquo;s easy to make a costly mistake. In fact, coming as a developer from a typical backend or frontend engineering role, it feels a bit like going back to writing C. Mistakes are easy to make, easy to miss, and easy to misjudge. Rust is a language that sells safety as a feature, but when it comes to smart contracts, it&amp;rsquo;s not the null pointer that&amp;rsquo;s going to kill you, it&amp;rsquo;s forgetting to check an input, something that Rust can&amp;rsquo;t solve with memory safety.</description></item><item><title>Building Sequoia PGP on Windows</title><link>https://SchwarzBi3r.github.io/posts/2022-01-27-building-sequoia-pgp-on-windows/</link><pubDate>Thu, 27 Jan 2022 15:57:21 -0500</pubDate><guid>https://SchwarzBi3r.github.io/posts/2022-01-27-building-sequoia-pgp-on-windows/</guid><description>This is more for my own notes, but if you&amp;rsquo;re new to Windows development, it&amp;rsquo;s easy to get lost in the mix of MSVC and &amp;lsquo;mingw&amp;rsquo;. For the purposes of this post, the goal will be to build Sequoia PGP, a rust PGP implementation, in Windows using the &amp;lsquo;mingw&amp;rsquo; environment (which uses the Nettles cryptography library vs Windows Cryptography).
Summary of the steps Install Rustup using the official package Install the windows-gnu toolchain and set it to default Install MSYS2 Install the required packages from MSYS2 (clang, nettles, pkg-config) Update PATH Build using cargo Installation steps Install rustup Use the official package at rustup.</description></item><item><title>Playing with Solana Serialization</title><link>https://SchwarzBi3r.github.io/posts/2022-01-26-solana-serialization/</link><pubDate>Wed, 26 Jan 2022 12:03:43 -0500</pubDate><guid>https://SchwarzBi3r.github.io/posts/2022-01-26-solana-serialization/</guid><description>While exploring Solana, I wanted to get a better handle on how Solana serializes its own data. In order to do this I built a tool to quickly look at data on an account. Normally, consumers would have the RPC server parse the account data into its relevant fields. In my case, I&amp;rsquo;m looking at the raw data and ignoring any parsing in order to better understand the serialization handling.</description></item></channel></rss>