<!doctype html><html><head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge"><title>Anchor/Solana safety check you get for free - SchwarzBier</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="When you&rsquo;re writing any Solana contract, it&rsquo;s easy to make a costly mistake. In fact, coming as a developer from a typical backend or frontend engineering role, it feels a bit like going back to writing C. Mistakes are easy to make, easy to miss, and easy to misjudge. Rust is a language that sells safety as a feature, but when it comes to smart contracts, it&rsquo;s not the null pointer that&rsquo;s going to kill you, it&rsquo;s forgetting to check an input, something that Rust can&rsquo;t solve with memory safety.">
<meta property="og:image" content>
<meta property="og:title" content="Anchor/Solana safety check you get for free">
<meta property="og:description" content="When you&rsquo;re writing any Solana contract, it&rsquo;s easy to make a costly mistake. In fact, coming as a developer from a typical backend or frontend engineering role, it feels a bit like going back to writing C. Mistakes are easy to make, easy to miss, and easy to misjudge. Rust is a language that sells safety as a feature, but when it comes to smart contracts, it&rsquo;s not the null pointer that&rsquo;s going to kill you, it&rsquo;s forgetting to check an input, something that Rust can&rsquo;t solve with memory safety.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://SchwarzBi3r.github.io/posts/2022-02-22-solana-anchor-safety-checks/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-02-21T00:00:00+00:00">
<meta property="article:modified_time" content="2022-02-21T00:00:00+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Anchor/Solana safety check you get for free">
<meta name=twitter:description content="When you&rsquo;re writing any Solana contract, it&rsquo;s easy to make a costly mistake. In fact, coming as a developer from a typical backend or frontend engineering role, it feels a bit like going back to writing C. Mistakes are easy to make, easy to miss, and easy to misjudge. Rust is a language that sells safety as a feature, but when it comes to smart contracts, it&rsquo;s not the null pointer that&rsquo;s going to kill you, it&rsquo;s forgetting to check an input, something that Rust can&rsquo;t solve with memory safety.">
<link href=https://SchwarzBi3r.github.io/css/fonts.b685ac6f654695232de7b82a9143a46f9e049c8e3af3a21d9737b01f4be211d1.css rel=stylesheet>
<link rel=stylesheet type=text/css media=screen href=https://SchwarzBi3r.github.io/css/main.2f9b5946627215dc1ae7fa5f82bfc9cfcab000329136befeea5733f21e77d68f.css>
</head>
<body>
<div class=content><header>
<div class=main>
<a href=https://SchwarzBi3r.github.io>SchwarzBier</a>
</div>
<nav>
</nav>
</header>
<main>
<article>
<div class=title>
<h1 class=title>Anchor/Solana safety check you get for free</h1>
<div class=meta>Posted on Feb 21, 2022</div>
</div>
<section class=body>
<p>When you&rsquo;re writing any Solana contract, it&rsquo;s easy to make a costly mistake. In fact, coming as a developer from a typical backend or frontend engineering role, it feels a bit like going back to writing C. Mistakes are easy to make, easy to miss, and easy to misjudge. Rust is a language that sells safety as a feature, but when it comes to smart contracts, it&rsquo;s not the null pointer that&rsquo;s going to kill you, it&rsquo;s forgetting to check an input, something that Rust can&rsquo;t solve with memory safety.</p>
<p>One of the things I like about the Anchor project is their focus on putting a safety net around some of the more common actions a smart contract may make.</p>
<p>In this post, I want to look at two common mistakes and the way Anchor tries to fix them. I&rsquo;ll be basing part of this post off of <a href=https://blog.neodyme.io/posts/solana_common_pitfalls>Neodyme&rsquo;s excellent blog post outlining some of the pitfalls of Solana contract code</a></p>
<h2 id=failing-to-check-the-owner-of-the-account>Failing to check the owner of the account</h2>
<p>In this case, our contract is going to transfer some funds based on the data in a &lsquo;config&rsquo; account which specifies the authority/admin of the funds. See Neodyme&rsquo;s demonstration code below:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>withdraw_token_restricted</span>(program_id: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Pubkey</span>, accounts: <span style=color:#66d9ef>&amp;</span>[AccountInfo], amount: <span style=color:#66d9ef>u64</span>) -&gt; <span style=color:#a6e22e>ProgramResult</span> {
    <span style=color:#66d9ef>let</span> account_iter <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> accounts.iter();
    <span style=color:#66d9ef>let</span> vault <span style=color:#f92672>=</span> next_account_info(account_iter)<span style=color:#f92672>?</span>;
    <span style=color:#66d9ef>let</span> admin <span style=color:#f92672>=</span> next_account_info(account_iter)<span style=color:#f92672>?</span>;
    <span style=color:#66d9ef>let</span> config <span style=color:#f92672>=</span> ConfigAccount::unpack(next_account_info(account_iter)<span style=color:#f92672>?</span>)<span style=color:#f92672>?</span>;
    <span style=color:#66d9ef>let</span> vault_authority <span style=color:#f92672>=</span> next_account_info(account_iter)<span style=color:#f92672>?</span>;
    
    
    <span style=color:#66d9ef>if</span> config.admin <span style=color:#f92672>!=</span> admin.pubkey() {
        <span style=color:#66d9ef>return</span> Err(ProgramError::InvalidAdminAccount);
    }
    
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>    <span style=color:#75715e>// Transfer funds from vault to admin using vault_authority
</span><span style=color:#75715e></span>    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>    
    Ok(())
}
</code></pre></div><p>What may or may not immediately stand out is the <code>config.admin != admin.pubkey()</code> check. In this case the developer is assuming that our program owns <code>config</code>, but that&rsquo;s not guaranteed. Anyone may pass in a config account owned by another program and with their own data labelling themselves as the correct admin.</p>
<p>The solution is to check the owner of the account, which is a field you&rsquo;ll find on every Solana account. If you were doing this in vanilla Solana it would look like:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>if</span> config.owner <span style=color:#f92672>!=</span> program_id {
        <span style=color:#66d9ef>return</span> Err(ProgramError::InvalidConfigAccount);
    }
    
    <span style=color:#66d9ef>if</span> config.admin <span style=color:#f92672>!=</span> admin.pubkey() {
        <span style=color:#66d9ef>return</span> Err(ProgramError::InvalidAdminAccount);
    }
</code></pre></div><p>In most cases, you&rsquo;d want to do this for every program account. But in Anchor, this check is performed by default on all Accounts (Anchor&rsquo;s rust representation of a solana account).</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>#[account]</span>
<span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Config</span> {
    <span style=color:#66d9ef>pub</span> admin: <span style=color:#a6e22e>Pubkey</span>,
}

<span style=color:#75715e>#[derive(Accounts)]</span>
<span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Initialize</span><span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>info</span><span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>pub</span> admin: <span style=color:#a6e22e>Signer</span><span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>info</span><span style=color:#f92672>&gt;</span>,
    <span style=color:#66d9ef>pub</span> config: <span style=color:#a6e22e>Account</span><span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>info</span>, Config<span style=color:#f92672>&gt;</span>,
}
</code></pre></div><p>In the above example, Anchor has been told about what will be passed to out <code>Initialize</code> function (a Signer account, and a Config Account), which will then be loaded through it&rsquo;s <a href=https://github.com/project-serum/anchor/blob/master/lang/src/accounts/account.rs#L249>Account struct</a>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_from</span>(info: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>AccountInfo</span><span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>a</span><span style=color:#f92672>&gt;</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Account<span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>a</span>, T<span style=color:#f92672>&gt;</span>, ProgramError<span style=color:#f92672>&gt;</span> {
        <span style=color:#66d9ef>if</span> info.owner <span style=color:#f92672>==</span> <span style=color:#f92672>&amp;</span>system_program::ID <span style=color:#f92672>&amp;&amp;</span> info.lamports() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
            <span style=color:#66d9ef>return</span> Err(ErrorCode::AccountNotInitialized.into());
        }
        <span style=color:#66d9ef>if</span> info.owner <span style=color:#f92672>!=</span> <span style=color:#f92672>&amp;</span>T::owner() {
            <span style=color:#66d9ef>return</span> Err(ErrorCode::AccountOwnedByWrongProgram.into());
        }
        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> data: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>u8</span>] <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>info.try_borrow_data()<span style=color:#f92672>?</span>;
        Ok(Account::new(info.clone(), T::try_deserialize(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> data)<span style=color:#f92672>?</span>))
    }
</code></pre></div><p>You&rsquo;ll notice that the second sanity check is to see if the owner of an account matches the program owner. This is the default behavior for &lsquo;Account&rsquo; types in Anchor, which give you some assurance that any data loaded from an account belongs to the program that put it there (Quick side note: In Solana, a program can&rsquo;t &lsquo;assign&rsquo; new ownership to an account with data in it, so this assures you can any data in an account belongs to the account owner/program that created it.)</p>
<h2 id=failing-to-check-the-signer-is-actually-the-signer>Failing to check the signer is actually the signer</h2>
<p>This is another easy to miss gotcha that Anchor solves rather easily.</p>
<p>Lets look again at Neodyme&rsquo;s excellent example:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_from</span>(info: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>AccountInfo</span><span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>a</span><span style=color:#f92672>&gt;</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Account<span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>a</span>, T<span style=color:#f92672>&gt;</span>, ProgramError<span style=color:#f92672>&gt;</span> {
<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>update_admin</span>(program_id: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Pubkey</span>, accounts: <span style=color:#66d9ef>&amp;</span>[AccountInfo]) -&gt; <span style=color:#a6e22e>ProgramResult</span> {
    <span style=color:#66d9ef>let</span> account_iter <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> accounts.iter();
    <span style=color:#66d9ef>let</span> config <span style=color:#f92672>=</span> ConfigAccount::unpack(next_account_info(account_iter)<span style=color:#f92672>?</span>)<span style=color:#f92672>?</span>;
    <span style=color:#66d9ef>let</span> admin <span style=color:#f92672>=</span> next_account_info(account_iter)<span style=color:#f92672>?</span>;
    <span style=color:#66d9ef>let</span> new_admin <span style=color:#f92672>=</span> next_account_info(account_iter)<span style=color:#f92672>?</span>;

    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>    <span style=color:#75715e>// Validate the config account...
</span><span style=color:#75715e></span>    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>    
    <span style=color:#66d9ef>if</span> admin.pubkey() <span style=color:#f92672>!=</span> config.admin {
        <span style=color:#66d9ef>return</span> Err(ProgramError::InvalidAdminAccount);
    }
    
    config.admin <span style=color:#f92672>=</span> new_admin.pubkey();
    
    Ok(())
}
</code></pre></div><p>In this case, we haven&rsquo;t checked that the <code>admin</code> account passed to us is a signer of the transaction. This is a really nasty bug that&rsquo;s easy to miss.</p>
<p>And now, let&rsquo;s look at how Anchor resolves it. When we specify the list of accounts we expect to be passed to our function, we can actually call out &lsquo;admin&rsquo; as a Signer. This is the same code from the above example; we haven&rsquo;t had to add anything:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>#[derive(Accounts)]</span>
<span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Initialize</span><span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>info</span><span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>pub</span> admin: <span style=color:#a6e22e>Signer</span><span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>info</span><span style=color:#f92672>&gt;</span>,
    <span style=color:#66d9ef>pub</span> config: <span style=color:#a6e22e>Account</span><span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>info</span>, Config<span style=color:#f92672>&gt;</span>,
}
</code></pre></div><p>The magic happens when Anchor goes to <a href=https://github.com/project-serum/anchor/blob/master/lang/src/accounts/signer.rs#L51>deserialize the account before passing it along to our contract function</a>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>info</span><span style=color:#f92672>&gt;</span> Signer<span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>info</span><span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(info: <span style=color:#a6e22e>AccountInfo</span><span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>info</span><span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#a6e22e>Signer</span><span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>info</span><span style=color:#f92672>&gt;</span> {
        Self { info }
    }

    <span style=color:#e6db74>/// Deserializes the given `info` into a `Signer`.
</span><span style=color:#e6db74></span>    <span style=color:#75715e>#[inline(never)]</span>
    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_from</span>(info: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>AccountInfo</span><span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>info</span><span style=color:#f92672>&gt;</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Signer<span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>info</span><span style=color:#f92672>&gt;&gt;</span> {
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>info.is_signer {
            <span style=color:#66d9ef>return</span> Err(ErrorCode::AccountNotSigner.into());
        }
        Ok(Signer::new(info.clone()))
    }
}
</code></pre></div><p>And that&rsquo;s it. By simply declaring an account a <code>Signer</code> we can some quick safety rails on the transaction.</p>
<h2 id=summary>Summary</h2>
<p>Anchor isn&rsquo;t going to solve all your problems this easily, but it does provide a great place to start. Combined with the other tooling it provides, I&rsquo;d be hard-pressed to recommend anyone write a Solana contract without it.</p>
<p>You can still shoot yourself in the foot, but Anchor at least removes a couple of the foot guns, and at very little cost to the developer.</p>
</section>
<div class=post-tags>
</div>
</article>
</main>
<footer>
<hr>⚡️
2022 Schwarzbier | Built with <a href=https://gohugo.io>Hugo</a>
</footer>
</div>
</body>
</html>