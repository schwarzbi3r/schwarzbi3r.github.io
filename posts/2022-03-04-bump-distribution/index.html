<!doctype html><html><head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge"><title>Bump distribution of findProgramAddress - SchwarzBier</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="There&rsquo;s some frequent misunderstanding when it comes to PDA&rsquo;s on Solana, starting with the &lsquo;bump&rsquo; value.
First, let&rsquo;s look at what makes up a PDA. A PDA, or Program Derived Address, is an address on Solana that satifies two requirements.
  &ldquo;Program address must not lie on the ed25519 curve to ensure there is no associated private key&rdquo; - This means that there&rsquo;s no corresponding private key for the public address; no one will ever be able to sign a transaction with this key.">
<meta property="og:image" content>
<meta property="og:title" content="Bump distribution of findProgramAddress">
<meta property="og:description" content="There&rsquo;s some frequent misunderstanding when it comes to PDA&rsquo;s on Solana, starting with the &lsquo;bump&rsquo; value.
First, let&rsquo;s look at what makes up a PDA. A PDA, or Program Derived Address, is an address on Solana that satifies two requirements.
  &ldquo;Program address must not lie on the ed25519 curve to ensure there is no associated private key&rdquo; - This means that there&rsquo;s no corresponding private key for the public address; no one will ever be able to sign a transaction with this key.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://SchwarzBi3r.github.io/posts/2022-03-04-bump-distribution/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-03-04T00:00:00+00:00">
<meta property="article:modified_time" content="2022-03-04T00:00:00+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Bump distribution of findProgramAddress">
<meta name=twitter:description content="There&rsquo;s some frequent misunderstanding when it comes to PDA&rsquo;s on Solana, starting with the &lsquo;bump&rsquo; value.
First, let&rsquo;s look at what makes up a PDA. A PDA, or Program Derived Address, is an address on Solana that satifies two requirements.
  &ldquo;Program address must not lie on the ed25519 curve to ensure there is no associated private key&rdquo; - This means that there&rsquo;s no corresponding private key for the public address; no one will ever be able to sign a transaction with this key.">
<link href=https://SchwarzBi3r.github.io/css/fonts.b685ac6f654695232de7b82a9143a46f9e049c8e3af3a21d9737b01f4be211d1.css rel=stylesheet>
<link rel=stylesheet type=text/css media=screen href=https://SchwarzBi3r.github.io/css/main.2f9b5946627215dc1ae7fa5f82bfc9cfcab000329136befeea5733f21e77d68f.css>
</head>
<body>
<div class=content><header>
<div class=main>
<a href=https://SchwarzBi3r.github.io>SchwarzBier</a>
</div>
<nav>
</nav>
</header>
<main>
<article>
<div class=title>
<h1 class=title>Bump distribution of findProgramAddress</h1>
<div class=meta>Posted on Mar 4, 2022</div>
</div>
<section class=body>
<p>There&rsquo;s some frequent misunderstanding when it comes to PDA&rsquo;s on Solana, starting with the &lsquo;bump&rsquo; value.</p>
<p>First, let&rsquo;s look at what makes up a PDA. A PDA, or Program Derived Address, is an address on Solana that satifies two requirements.</p>
<ol>
<li>
<p>&ldquo;Program address must not lie on the ed25519 curve to ensure there is no associated private key&rdquo; - This means that there&rsquo;s no corresponding private key for the public address; no one will ever be able to sign a transaction with this key. What are the odds of that happening? It turns out that randomly generating a new keypair on ed25519 results in a valid pair 50% of the time. We&rsquo;ll get to this later.</p>
</li>
<li>
<p>The PDA needs to have some tie to its program owner. We achieve this by always using the program&rsquo;s address as a seed to generate the PDA address. Regardless of what other seeds you decide to include (eg. the token holders address), since it always includes with the program&rsquo;s address, it&rsquo;s essentially locked to that particular program.</p>
</li>
</ol>
<p>Let&rsquo;s look at the code</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>async</span> findProgramAddress(
    seeds: <span style=color:#a6e22e>Array</span><span style=color:#f92672>&lt;</span>Buffer <span style=color:#f92672>|</span> Uint8Array<span style=color:#f92672>&gt;</span>,
    programId: <span style=color:#a6e22e>PublicKey</span>,
): <span style=color:#a6e22e>Promise</span><span style=color:#f92672>&lt;</span>[PublicKey, number]<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>let</span> bump <span style=color:#f92672>=</span> <span style=color:#ae81ff>255</span>;
    <span style=color:#66d9ef>let</span> address;
    <span style=color:#66d9ef>while</span> (bump <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
        <span style=color:#66d9ef>try</span> {
        <span style=color:#66d9ef>const</span> seedsWithBump <span style=color:#f92672>=</span> seeds.concat(Buffer.from([bump]));
        address <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> this.createProgramAddress(seedsWithBump, programId);
        } catch (err) {
        <span style=color:#66d9ef>if</span> (err instanceof TypeError) {
            throw err;
        }
        bump<span style=color:#f92672>--</span>;
        <span style=color:#66d9ef>continue</span>;
        }
        <span style=color:#66d9ef>return</span> [address, bump];
    }
    throw new Error(<span style=color:#960050;background-color:#1e0010>`</span>Unable to find a viable program address bump<span style=color:#960050;background-color:#1e0010>`</span>);
}
</code></pre></div><p>You can see the structure pretty clearly, and if you put it all together you end up with seed that looks like</p>
<pre tabindex=0><code>[&quot;MyFirstSeed&quot;, &quot;AnotherSeed&quot;, bump]
</code></pre><p>And if that doesn&rsquo;t result in a valid PDA (no valid private key) we decrement bump (which starts at 255) and try again.</p>
<p>Finally, let&rsquo;s dive into the &lsquo;createProgramAddress&rsquo; to see the full structure and hashing:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>async</span> createProgramAddress(
    seeds: <span style=color:#a6e22e>Array</span><span style=color:#f92672>&lt;</span>Buffer <span style=color:#f92672>|</span> Uint8Array<span style=color:#f92672>&gt;</span>,
    programId: <span style=color:#a6e22e>PublicKey</span>,
): <span style=color:#a6e22e>Promise</span><span style=color:#f92672>&lt;</span>PublicKey<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>let</span> buffer <span style=color:#f92672>=</span> Buffer.alloc(<span style=color:#ae81ff>0</span>);
    seeds.forEach(function (seed) {
        <span style=color:#66d9ef>if</span> (seed.length <span style=color:#f92672>&gt;</span> MAX_SEED_LENGTH) {
        throw new TypeError(<span style=color:#960050;background-color:#1e0010>`</span>Max seed length exceeded<span style=color:#960050;background-color:#1e0010>`</span>);
        }
        buffer <span style=color:#f92672>=</span> Buffer.concat([buffer, toBuffer(seed)]);
    });
    buffer <span style=color:#f92672>=</span> Buffer.concat([
        buffer,
        programId.toBuffer(),
        Buffer.from(<span style=color:#f92672>&#39;</span><span style=color:#a6e22e>ProgramDerivedAddress</span><span style=color:#f92672>&#39;</span>),
    ]);
    <span style=color:#66d9ef>let</span> hash <span style=color:#f92672>=</span> sha256(new Uint8Array(buffer)).slice(<span style=color:#ae81ff>2</span>);
    <span style=color:#66d9ef>let</span> publicKeyBytes <span style=color:#f92672>=</span> new BN(hash, <span style=color:#ae81ff>16</span>).toArray(undefined, <span style=color:#ae81ff>32</span>);
    <span style=color:#66d9ef>if</span> (is_on_curve(publicKeyBytes)) {
        throw new Error(<span style=color:#960050;background-color:#1e0010>`</span>Invalid seeds, address must fall off the curve<span style=color:#960050;background-color:#1e0010>`</span>);
    }
    <span style=color:#66d9ef>return</span> new PublicKey(publicKeyBytes);
}

</code></pre></div><p>So now we see the whole seed which gets hashed to create a potential PDA:</p>
<pre tabindex=0><code>[&quot;MySeed&quot;, &quot;AnotherSeed&quot;, bump, programAddress, &quot;ProgramDerivedAddress&quot;]
</code></pre><p>On the validator side of things, when my program wants to sign a transaction, it simply supplies the seeds and the bump, and the validator runs it through this instruction along with the program address and confirms that it matches the PDA I&rsquo;m asking to sign for.</p>
<h2 id=distribution>Distribution</h2>
<p>Ok, so let&rsquo;s actually look at the distribution and verify this is happening as often as predicted. <a href=https://codesandbox.io/s/findprogramaddress-distribution-et07bv>I built a quick demo on CodeSandbox to randomly generate PDA&rsquo;s and aggregate the bumps returned for each one</a>. Remember, each time we attempt to generate a random PDA, it should be valid 50% of the time. Which means we should see ~50% of bumps at 255, ~25% at 254, ~12.5% at 253 and so on.</p>
<p>And here&rsquo;s the result:</p>
<p><img src=/2022-03-04-bump-distribution/distribution.png alt=bump-distribution></p>
<p>Hopefully, this helps clear up what&rsquo;s happening behind the scenes when we use findProgramAddress.</p>
</section>
<div class=post-tags>
</div>
</article>
</main>
<footer>
<hr>⚡️
2022 Schwarzbier | Built with <a href=https://gohugo.io>Hugo</a>
</footer>
</div>
</body>
</html>